---
title: |-
  [알고리즘 프로그래머스] 시저 암호
   (LEVEL 1)
tag:
- 알고리즘
- 프로그래머스 LEVEL1
categories:
- algorithm
---

# (문제) 시저 암호
---

어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다.

예를 들어 `AB`는 1만큼 밀면 `BC`가 되고, 3만큼 밀면 `DE`가 됩니다.

`z`는 1만큼 밀면 `a`가 됩니다.

문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.

> **입력설명**

첫번째 입력으로는 s 즉, 문자가 들어옵니다.

두번째 입력으로는 n 즉, 미는 만큼이 들어옵니다

공백은 아무리 밀어도 공백입니다.

s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다.

s의 길이는 8000이하입니다.

n은 1 이상, 25이하인 자연수입니다.


> **출력설명**

문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.

> **테스트케이스**
 

| 입력예제 | 출력예제 |
| -------- | -------- | 
| "AB" 1 | "BC" | 
| "z" 1 | "a" | 
| "a B z" 4 | "e F d" | 

---
# 해결방법

ASCII 코드를 이용하여 문제 해결을 하려고 한다.

A -> 65 / a -> 97

문자열을 순회하여 각 문자의 아스키코드를 값을 구한다.

만약 문자가 A~Z 일경우 아스키코드로 변환한 글자를 - 65 하고 + n 만큼 더하고 그것을 % 로 알파벳 개수만큼 나눈다.

그 후 -65 를 했던 것을 원상 복구를 시키기 위해서 +65를 한다.

a~z 또한 마찬가지로 위와 같은 과정을 65를 97로 생각을하고 작업을 한다.

만약 a~z 또는 A~Z가 아닐 경우 그냥 그 글자를 그대로 이용한다.

---
# 코드
```python
s, n = input().split()

n = int(n)

answer = ""

for word in s:
    if 'A' <= word <= 'Z':
        answer = answer + chr((ord(word) - 65 + n) % 26 + 65)
    elif 'a' <= word <= 'z':
        answer = answer + chr((ord(word) - 97 + n) % 26 + 97)
    else:
        answer = answer + word

print(answer)
```
