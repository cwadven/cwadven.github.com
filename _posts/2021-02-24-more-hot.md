---
title: "[알고리즘 프로그래머스] 더 맵게 (LEVEL 2)"
tag:
- 알고리즘
- 프로그래머스 LEVEL2
categories:
- algorithm
---

# (문제) 더 맵게 (LEVEL 2) [힙]
---

매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다.

모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.

~~~
섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)
~~~

Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.

Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.


> **입력설명**

첫번째 입력으로는 scoville, 두번째 입력으로는 K 가 들어옵니다.

scoville의 길이는 2 이상 1,000,000 이하입니다.

K는 0 이상 1,000,000,000 이하입니다.

scoville의 원소는 각각 0 이상 1,000,000 이하입니다.

모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.

> **출력설명**

Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return

> **테스트케이스**
 

| 입력예제 | 출력예제 |
| -------- | -------- | 
| [1, 2, 3, 9, 10, 12]	7	| 2 | 

~~~
입출력 예 설명
스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.
새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5
가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]

스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.
새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13
가진 음식의 스코빌 지수 = [13, 9, 10, 12]

모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.
~~~

---
# 해결방법

힙으로 풀어야하는 문제이다.

우선 힙의 자료구조가 어떻게 되는지 공부해보자.<br>
(아래 링크를 이용하여 보면 알 수 있다)

[(링크) 힙이란?? 무엇인가!](https://cwadven.github.io/data_structures/heap/)

그러면 문제를 해결하기 위해 힙정렬을 해야한다.

힙 정렬은 Python 모듈로 이미 만들어져 있어서 그냥 가져다 사용하면 된다.

```python
import heapq as hq
```

필자는 heapq가 너무 기니 as 로 이름을 변경했다.

힙에 대한 메서드

* 힙정렬 : hq.heapify(정렬할리스트)
* 힙추출 : hq.heappop(뺄리스트)
* 힙삽입 : hq.heappush(넣을리스트, 넣을 값)

자 그러면 scoville 안에 값이 있을 경우, 그리고 맨 앞에 있는 것이 K 스코빌 지수보다 작을 경우 계속 반복하도록 한다.

왜 맨 앞에 있는 것이라고 하냐면 힙 메서드를 이용해서 힙정렬을 하면 무조건 작은게 맨 앞에 있기 때문이다.

이럴 경우 문제가 생길 수 있다!

[0, 0, 0, 0, 0] 이라고 가정을 했을 때 K 스코빌 지수를 8 이라고 하자!

그러면 작은 것 2개를 빼는데, 이때 0과 0이 빠져서 0 + (0 * 2) 를 하면 0 이 된다.

이 값이 K 스코빌 지수 8을 넘지 못하므로 다시 리스트에 heappush로 넣어서 계속 반복을 하는데...

이러면 마지막에 [0] 1개만 남는 경우가 생긴다.

하지만 2개르 뽑아야하는데, 그래서 인덱스 오류가 난다!

그렇기 때문에 필자는 try except 예외처리를 사용하여 만약 예외가 발생하면 return -1 하도록 만들 었다!

---
# 코드
```python
import heapq as hq

def solution(scoville, K):
    # 힙정렬
    count = 0
    hq.heapify(scoville)
    while scoville and scoville[0] < K:
        try:
            first = hq.heappop(scoville)
            second = hq.heappop(scoville)
            hq.heappush(scoville, first+(second*2))
            count = count + 1
        except:
            return -1
    return count
```
