---
title: "[알고리즘] 창고정리"
tag:
- 알고리즘
categories:
- algorithm
---

# (문제) 창고정리
---

창고에 상자가 가로방향으로 일렬로 쌓여 있습니다.

만약 가로의 길이가 7이라면

![]({{ 'assets/images/algorithm/warehouse/warehouse1.PNG' | relative_url }})<br><br>

1열은 높이가 6으로 6개의 상자가 쌓여 있고, 2열은 3개의 상자, 3열은 9개의 상자가 쌓여 있으며 높이는 9라고 읽는다.

창고 높이 조정은 가장 높은 곳에 상자를 가장 낮은 곳으로 이동하는 것을 말한다.

가장 높은 곳이나 가장 낮은 곳이 여러곳이면 그 중 아무거나 선택하면 된다.

위에 그림을 1회 높이 조정을 하면 다음과 같아진다.

![]({{ 'assets/images/algorithm/warehouse/warehouse2.PNG' | relative_url }})<br><br>

창고의 가로 길이와 각 열의 상자 높이가 주어집니다.

m회의 높이 조정을 한 후 가장 높은 곳과 가장 낮은 곳의 차이를 출력하는 프로그램을 작성하세요.

> **입력설명**

첫 번째 줄에 창고 가로의 길이인 자연수 L(1<=L<=100)이 주어집니다.

두 번째 줄에 L개의 자연수가 공백을 사이에 두고 입력됩니다.

각 자연수는 100을 넘지않습니다.

세 번째 줄에 높이 조정 횟수인 M(1<=M<=1,000)이 주어집니다.

> **출력설명**

M회의 높이 조정을 마친 후 가장 높은곳과 가장 낮은 곳의 차이를 출력하세요.

> **테스트케이스**
 

| 입력예제 | 출력예제 |
| -------- | -------- | 
| 10<br>69 42 68 76 40 87 14 65 76 81<br>50 | 20 | 
| 20<br>56 80 91 56 36 97 47 15 12 70 40 71 66 10 12 68 72 38 31 55 <br>150 | 16 | 


---
# 해결방법

가장 많이 쌓여있는 상자와 가장 적게 쌓여있는 상자의 위치를 알기 위해서 내림차 순으로 정렬한다.

그러면 맨 첫번째 인덱스는 상자가 많은 자리, 맨 마지막은 상자가 적은 자리 라는 것을 알 수 있다.

그러면 이제 첫번째 인덱스에 있는 값을 하나 빼고, 마지막에 있는 인덱스의 값에 + 1 한다.

그것을 M 번만큼 반복을 하는데, 반복 할 때마다 계속 정렬을 똑같이 내림차 순으로 정렬한다.

---
# 코드
```python
L = int(input())

arr = list(map(int, input().split()))

M = int(input())

while M:
    arr.sort(reverse=True)
    arr[0] = arr[0] - 1
    arr[-1] = arr[-1] + 1
    M = M - 1

print(max(arr)-min(arr))
```
